// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"database/sql"
	"sync"

	"github.com/DueIt-Jasanya-Aturuang/one-piece/domain"
)

type FakePaymentRepository struct {
	CloseConnStub        func()
	closeConnMutex       sync.RWMutex
	closeConnArgsForCall []struct {
	}
	CreatePaymentStub        func(context.Context, *domain.Payment) error
	createPaymentMutex       sync.RWMutex
	createPaymentArgsForCall []struct {
		arg1 context.Context
		arg2 *domain.Payment
	}
	createPaymentReturns struct {
		result1 error
	}
	createPaymentReturnsOnCall map[int]struct {
		result1 error
	}
	GetAllPaymentStub        func(context.Context) (*[]domain.Payment, error)
	getAllPaymentMutex       sync.RWMutex
	getAllPaymentArgsForCall []struct {
		arg1 context.Context
	}
	getAllPaymentReturns struct {
		result1 *[]domain.Payment
		result2 error
	}
	getAllPaymentReturnsOnCall map[int]struct {
		result1 *[]domain.Payment
		result2 error
	}
	GetConnStub        func() (*sql.Conn, error)
	getConnMutex       sync.RWMutex
	getConnArgsForCall []struct {
	}
	getConnReturns struct {
		result1 *sql.Conn
		result2 error
	}
	getConnReturnsOnCall map[int]struct {
		result1 *sql.Conn
		result2 error
	}
	GetPaymentByIDStub        func(context.Context, string) (*domain.Payment, error)
	getPaymentByIDMutex       sync.RWMutex
	getPaymentByIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getPaymentByIDReturns struct {
		result1 *domain.Payment
		result2 error
	}
	getPaymentByIDReturnsOnCall map[int]struct {
		result1 *domain.Payment
		result2 error
	}
	GetPaymentByNameStub        func(context.Context, string) (*domain.Payment, error)
	getPaymentByNameMutex       sync.RWMutex
	getPaymentByNameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getPaymentByNameReturns struct {
		result1 *domain.Payment
		result2 error
	}
	getPaymentByNameReturnsOnCall map[int]struct {
		result1 *domain.Payment
		result2 error
	}
	GetTxStub        func() (*sql.Tx, error)
	getTxMutex       sync.RWMutex
	getTxArgsForCall []struct {
	}
	getTxReturns struct {
		result1 *sql.Tx
		result2 error
	}
	getTxReturnsOnCall map[int]struct {
		result1 *sql.Tx
		result2 error
	}
	OpenConnStub        func(context.Context) error
	openConnMutex       sync.RWMutex
	openConnArgsForCall []struct {
		arg1 context.Context
	}
	openConnReturns struct {
		result1 error
	}
	openConnReturnsOnCall map[int]struct {
		result1 error
	}
	StartTxStub        func(context.Context, *sql.TxOptions, func() error) error
	startTxMutex       sync.RWMutex
	startTxArgsForCall []struct {
		arg1 context.Context
		arg2 *sql.TxOptions
		arg3 func() error
	}
	startTxReturns struct {
		result1 error
	}
	startTxReturnsOnCall map[int]struct {
		result1 error
	}
	UpdatePaymentStub        func(context.Context, *domain.Payment) error
	updatePaymentMutex       sync.RWMutex
	updatePaymentArgsForCall []struct {
		arg1 context.Context
		arg2 *domain.Payment
	}
	updatePaymentReturns struct {
		result1 error
	}
	updatePaymentReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePaymentRepository) CloseConn() {
	fake.closeConnMutex.Lock()
	fake.closeConnArgsForCall = append(fake.closeConnArgsForCall, struct {
	}{})
	stub := fake.CloseConnStub
	fake.recordInvocation("CloseConn", []interface{}{})
	fake.closeConnMutex.Unlock()
	if stub != nil {
		fake.CloseConnStub()
	}
}

func (fake *FakePaymentRepository) CloseConnCallCount() int {
	fake.closeConnMutex.RLock()
	defer fake.closeConnMutex.RUnlock()
	return len(fake.closeConnArgsForCall)
}

func (fake *FakePaymentRepository) CloseConnCalls(stub func()) {
	fake.closeConnMutex.Lock()
	defer fake.closeConnMutex.Unlock()
	fake.CloseConnStub = stub
}

func (fake *FakePaymentRepository) CreatePayment(arg1 context.Context, arg2 *domain.Payment) error {
	fake.createPaymentMutex.Lock()
	ret, specificReturn := fake.createPaymentReturnsOnCall[len(fake.createPaymentArgsForCall)]
	fake.createPaymentArgsForCall = append(fake.createPaymentArgsForCall, struct {
		arg1 context.Context
		arg2 *domain.Payment
	}{arg1, arg2})
	stub := fake.CreatePaymentStub
	fakeReturns := fake.createPaymentReturns
	fake.recordInvocation("CreatePayment", []interface{}{arg1, arg2})
	fake.createPaymentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePaymentRepository) CreatePaymentCallCount() int {
	fake.createPaymentMutex.RLock()
	defer fake.createPaymentMutex.RUnlock()
	return len(fake.createPaymentArgsForCall)
}

func (fake *FakePaymentRepository) CreatePaymentCalls(stub func(context.Context, *domain.Payment) error) {
	fake.createPaymentMutex.Lock()
	defer fake.createPaymentMutex.Unlock()
	fake.CreatePaymentStub = stub
}

func (fake *FakePaymentRepository) CreatePaymentArgsForCall(i int) (context.Context, *domain.Payment) {
	fake.createPaymentMutex.RLock()
	defer fake.createPaymentMutex.RUnlock()
	argsForCall := fake.createPaymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentRepository) CreatePaymentReturns(result1 error) {
	fake.createPaymentMutex.Lock()
	defer fake.createPaymentMutex.Unlock()
	fake.CreatePaymentStub = nil
	fake.createPaymentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentRepository) CreatePaymentReturnsOnCall(i int, result1 error) {
	fake.createPaymentMutex.Lock()
	defer fake.createPaymentMutex.Unlock()
	fake.CreatePaymentStub = nil
	if fake.createPaymentReturnsOnCall == nil {
		fake.createPaymentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createPaymentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentRepository) GetAllPayment(arg1 context.Context) (*[]domain.Payment, error) {
	fake.getAllPaymentMutex.Lock()
	ret, specificReturn := fake.getAllPaymentReturnsOnCall[len(fake.getAllPaymentArgsForCall)]
	fake.getAllPaymentArgsForCall = append(fake.getAllPaymentArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetAllPaymentStub
	fakeReturns := fake.getAllPaymentReturns
	fake.recordInvocation("GetAllPayment", []interface{}{arg1})
	fake.getAllPaymentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentRepository) GetAllPaymentCallCount() int {
	fake.getAllPaymentMutex.RLock()
	defer fake.getAllPaymentMutex.RUnlock()
	return len(fake.getAllPaymentArgsForCall)
}

func (fake *FakePaymentRepository) GetAllPaymentCalls(stub func(context.Context) (*[]domain.Payment, error)) {
	fake.getAllPaymentMutex.Lock()
	defer fake.getAllPaymentMutex.Unlock()
	fake.GetAllPaymentStub = stub
}

func (fake *FakePaymentRepository) GetAllPaymentArgsForCall(i int) context.Context {
	fake.getAllPaymentMutex.RLock()
	defer fake.getAllPaymentMutex.RUnlock()
	argsForCall := fake.getAllPaymentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePaymentRepository) GetAllPaymentReturns(result1 *[]domain.Payment, result2 error) {
	fake.getAllPaymentMutex.Lock()
	defer fake.getAllPaymentMutex.Unlock()
	fake.GetAllPaymentStub = nil
	fake.getAllPaymentReturns = struct {
		result1 *[]domain.Payment
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) GetAllPaymentReturnsOnCall(i int, result1 *[]domain.Payment, result2 error) {
	fake.getAllPaymentMutex.Lock()
	defer fake.getAllPaymentMutex.Unlock()
	fake.GetAllPaymentStub = nil
	if fake.getAllPaymentReturnsOnCall == nil {
		fake.getAllPaymentReturnsOnCall = make(map[int]struct {
			result1 *[]domain.Payment
			result2 error
		})
	}
	fake.getAllPaymentReturnsOnCall[i] = struct {
		result1 *[]domain.Payment
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) GetConn() (*sql.Conn, error) {
	fake.getConnMutex.Lock()
	ret, specificReturn := fake.getConnReturnsOnCall[len(fake.getConnArgsForCall)]
	fake.getConnArgsForCall = append(fake.getConnArgsForCall, struct {
	}{})
	stub := fake.GetConnStub
	fakeReturns := fake.getConnReturns
	fake.recordInvocation("GetConn", []interface{}{})
	fake.getConnMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentRepository) GetConnCallCount() int {
	fake.getConnMutex.RLock()
	defer fake.getConnMutex.RUnlock()
	return len(fake.getConnArgsForCall)
}

func (fake *FakePaymentRepository) GetConnCalls(stub func() (*sql.Conn, error)) {
	fake.getConnMutex.Lock()
	defer fake.getConnMutex.Unlock()
	fake.GetConnStub = stub
}

func (fake *FakePaymentRepository) GetConnReturns(result1 *sql.Conn, result2 error) {
	fake.getConnMutex.Lock()
	defer fake.getConnMutex.Unlock()
	fake.GetConnStub = nil
	fake.getConnReturns = struct {
		result1 *sql.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) GetConnReturnsOnCall(i int, result1 *sql.Conn, result2 error) {
	fake.getConnMutex.Lock()
	defer fake.getConnMutex.Unlock()
	fake.GetConnStub = nil
	if fake.getConnReturnsOnCall == nil {
		fake.getConnReturnsOnCall = make(map[int]struct {
			result1 *sql.Conn
			result2 error
		})
	}
	fake.getConnReturnsOnCall[i] = struct {
		result1 *sql.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) GetPaymentByID(arg1 context.Context, arg2 string) (*domain.Payment, error) {
	fake.getPaymentByIDMutex.Lock()
	ret, specificReturn := fake.getPaymentByIDReturnsOnCall[len(fake.getPaymentByIDArgsForCall)]
	fake.getPaymentByIDArgsForCall = append(fake.getPaymentByIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPaymentByIDStub
	fakeReturns := fake.getPaymentByIDReturns
	fake.recordInvocation("GetPaymentByID", []interface{}{arg1, arg2})
	fake.getPaymentByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentRepository) GetPaymentByIDCallCount() int {
	fake.getPaymentByIDMutex.RLock()
	defer fake.getPaymentByIDMutex.RUnlock()
	return len(fake.getPaymentByIDArgsForCall)
}

func (fake *FakePaymentRepository) GetPaymentByIDCalls(stub func(context.Context, string) (*domain.Payment, error)) {
	fake.getPaymentByIDMutex.Lock()
	defer fake.getPaymentByIDMutex.Unlock()
	fake.GetPaymentByIDStub = stub
}

func (fake *FakePaymentRepository) GetPaymentByIDArgsForCall(i int) (context.Context, string) {
	fake.getPaymentByIDMutex.RLock()
	defer fake.getPaymentByIDMutex.RUnlock()
	argsForCall := fake.getPaymentByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentRepository) GetPaymentByIDReturns(result1 *domain.Payment, result2 error) {
	fake.getPaymentByIDMutex.Lock()
	defer fake.getPaymentByIDMutex.Unlock()
	fake.GetPaymentByIDStub = nil
	fake.getPaymentByIDReturns = struct {
		result1 *domain.Payment
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) GetPaymentByIDReturnsOnCall(i int, result1 *domain.Payment, result2 error) {
	fake.getPaymentByIDMutex.Lock()
	defer fake.getPaymentByIDMutex.Unlock()
	fake.GetPaymentByIDStub = nil
	if fake.getPaymentByIDReturnsOnCall == nil {
		fake.getPaymentByIDReturnsOnCall = make(map[int]struct {
			result1 *domain.Payment
			result2 error
		})
	}
	fake.getPaymentByIDReturnsOnCall[i] = struct {
		result1 *domain.Payment
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) GetPaymentByName(arg1 context.Context, arg2 string) (*domain.Payment, error) {
	fake.getPaymentByNameMutex.Lock()
	ret, specificReturn := fake.getPaymentByNameReturnsOnCall[len(fake.getPaymentByNameArgsForCall)]
	fake.getPaymentByNameArgsForCall = append(fake.getPaymentByNameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPaymentByNameStub
	fakeReturns := fake.getPaymentByNameReturns
	fake.recordInvocation("GetPaymentByName", []interface{}{arg1, arg2})
	fake.getPaymentByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentRepository) GetPaymentByNameCallCount() int {
	fake.getPaymentByNameMutex.RLock()
	defer fake.getPaymentByNameMutex.RUnlock()
	return len(fake.getPaymentByNameArgsForCall)
}

func (fake *FakePaymentRepository) GetPaymentByNameCalls(stub func(context.Context, string) (*domain.Payment, error)) {
	fake.getPaymentByNameMutex.Lock()
	defer fake.getPaymentByNameMutex.Unlock()
	fake.GetPaymentByNameStub = stub
}

func (fake *FakePaymentRepository) GetPaymentByNameArgsForCall(i int) (context.Context, string) {
	fake.getPaymentByNameMutex.RLock()
	defer fake.getPaymentByNameMutex.RUnlock()
	argsForCall := fake.getPaymentByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentRepository) GetPaymentByNameReturns(result1 *domain.Payment, result2 error) {
	fake.getPaymentByNameMutex.Lock()
	defer fake.getPaymentByNameMutex.Unlock()
	fake.GetPaymentByNameStub = nil
	fake.getPaymentByNameReturns = struct {
		result1 *domain.Payment
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) GetPaymentByNameReturnsOnCall(i int, result1 *domain.Payment, result2 error) {
	fake.getPaymentByNameMutex.Lock()
	defer fake.getPaymentByNameMutex.Unlock()
	fake.GetPaymentByNameStub = nil
	if fake.getPaymentByNameReturnsOnCall == nil {
		fake.getPaymentByNameReturnsOnCall = make(map[int]struct {
			result1 *domain.Payment
			result2 error
		})
	}
	fake.getPaymentByNameReturnsOnCall[i] = struct {
		result1 *domain.Payment
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) GetTx() (*sql.Tx, error) {
	fake.getTxMutex.Lock()
	ret, specificReturn := fake.getTxReturnsOnCall[len(fake.getTxArgsForCall)]
	fake.getTxArgsForCall = append(fake.getTxArgsForCall, struct {
	}{})
	stub := fake.GetTxStub
	fakeReturns := fake.getTxReturns
	fake.recordInvocation("GetTx", []interface{}{})
	fake.getTxMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentRepository) GetTxCallCount() int {
	fake.getTxMutex.RLock()
	defer fake.getTxMutex.RUnlock()
	return len(fake.getTxArgsForCall)
}

func (fake *FakePaymentRepository) GetTxCalls(stub func() (*sql.Tx, error)) {
	fake.getTxMutex.Lock()
	defer fake.getTxMutex.Unlock()
	fake.GetTxStub = stub
}

func (fake *FakePaymentRepository) GetTxReturns(result1 *sql.Tx, result2 error) {
	fake.getTxMutex.Lock()
	defer fake.getTxMutex.Unlock()
	fake.GetTxStub = nil
	fake.getTxReturns = struct {
		result1 *sql.Tx
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) GetTxReturnsOnCall(i int, result1 *sql.Tx, result2 error) {
	fake.getTxMutex.Lock()
	defer fake.getTxMutex.Unlock()
	fake.GetTxStub = nil
	if fake.getTxReturnsOnCall == nil {
		fake.getTxReturnsOnCall = make(map[int]struct {
			result1 *sql.Tx
			result2 error
		})
	}
	fake.getTxReturnsOnCall[i] = struct {
		result1 *sql.Tx
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentRepository) OpenConn(arg1 context.Context) error {
	fake.openConnMutex.Lock()
	ret, specificReturn := fake.openConnReturnsOnCall[len(fake.openConnArgsForCall)]
	fake.openConnArgsForCall = append(fake.openConnArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.OpenConnStub
	fakeReturns := fake.openConnReturns
	fake.recordInvocation("OpenConn", []interface{}{arg1})
	fake.openConnMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePaymentRepository) OpenConnCallCount() int {
	fake.openConnMutex.RLock()
	defer fake.openConnMutex.RUnlock()
	return len(fake.openConnArgsForCall)
}

func (fake *FakePaymentRepository) OpenConnCalls(stub func(context.Context) error) {
	fake.openConnMutex.Lock()
	defer fake.openConnMutex.Unlock()
	fake.OpenConnStub = stub
}

func (fake *FakePaymentRepository) OpenConnArgsForCall(i int) context.Context {
	fake.openConnMutex.RLock()
	defer fake.openConnMutex.RUnlock()
	argsForCall := fake.openConnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePaymentRepository) OpenConnReturns(result1 error) {
	fake.openConnMutex.Lock()
	defer fake.openConnMutex.Unlock()
	fake.OpenConnStub = nil
	fake.openConnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentRepository) OpenConnReturnsOnCall(i int, result1 error) {
	fake.openConnMutex.Lock()
	defer fake.openConnMutex.Unlock()
	fake.OpenConnStub = nil
	if fake.openConnReturnsOnCall == nil {
		fake.openConnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.openConnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentRepository) StartTx(arg1 context.Context, arg2 *sql.TxOptions, arg3 func() error) error {
	fake.startTxMutex.Lock()
	ret, specificReturn := fake.startTxReturnsOnCall[len(fake.startTxArgsForCall)]
	fake.startTxArgsForCall = append(fake.startTxArgsForCall, struct {
		arg1 context.Context
		arg2 *sql.TxOptions
		arg3 func() error
	}{arg1, arg2, arg3})
	stub := fake.StartTxStub
	fakeReturns := fake.startTxReturns
	fake.recordInvocation("StartTx", []interface{}{arg1, arg2, arg3})
	fake.startTxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePaymentRepository) StartTxCallCount() int {
	fake.startTxMutex.RLock()
	defer fake.startTxMutex.RUnlock()
	return len(fake.startTxArgsForCall)
}

func (fake *FakePaymentRepository) StartTxCalls(stub func(context.Context, *sql.TxOptions, func() error) error) {
	fake.startTxMutex.Lock()
	defer fake.startTxMutex.Unlock()
	fake.StartTxStub = stub
}

func (fake *FakePaymentRepository) StartTxArgsForCall(i int) (context.Context, *sql.TxOptions, func() error) {
	fake.startTxMutex.RLock()
	defer fake.startTxMutex.RUnlock()
	argsForCall := fake.startTxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePaymentRepository) StartTxReturns(result1 error) {
	fake.startTxMutex.Lock()
	defer fake.startTxMutex.Unlock()
	fake.StartTxStub = nil
	fake.startTxReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentRepository) StartTxReturnsOnCall(i int, result1 error) {
	fake.startTxMutex.Lock()
	defer fake.startTxMutex.Unlock()
	fake.StartTxStub = nil
	if fake.startTxReturnsOnCall == nil {
		fake.startTxReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startTxReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentRepository) UpdatePayment(arg1 context.Context, arg2 *domain.Payment) error {
	fake.updatePaymentMutex.Lock()
	ret, specificReturn := fake.updatePaymentReturnsOnCall[len(fake.updatePaymentArgsForCall)]
	fake.updatePaymentArgsForCall = append(fake.updatePaymentArgsForCall, struct {
		arg1 context.Context
		arg2 *domain.Payment
	}{arg1, arg2})
	stub := fake.UpdatePaymentStub
	fakeReturns := fake.updatePaymentReturns
	fake.recordInvocation("UpdatePayment", []interface{}{arg1, arg2})
	fake.updatePaymentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePaymentRepository) UpdatePaymentCallCount() int {
	fake.updatePaymentMutex.RLock()
	defer fake.updatePaymentMutex.RUnlock()
	return len(fake.updatePaymentArgsForCall)
}

func (fake *FakePaymentRepository) UpdatePaymentCalls(stub func(context.Context, *domain.Payment) error) {
	fake.updatePaymentMutex.Lock()
	defer fake.updatePaymentMutex.Unlock()
	fake.UpdatePaymentStub = stub
}

func (fake *FakePaymentRepository) UpdatePaymentArgsForCall(i int) (context.Context, *domain.Payment) {
	fake.updatePaymentMutex.RLock()
	defer fake.updatePaymentMutex.RUnlock()
	argsForCall := fake.updatePaymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentRepository) UpdatePaymentReturns(result1 error) {
	fake.updatePaymentMutex.Lock()
	defer fake.updatePaymentMutex.Unlock()
	fake.UpdatePaymentStub = nil
	fake.updatePaymentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentRepository) UpdatePaymentReturnsOnCall(i int, result1 error) {
	fake.updatePaymentMutex.Lock()
	defer fake.updatePaymentMutex.Unlock()
	fake.UpdatePaymentStub = nil
	if fake.updatePaymentReturnsOnCall == nil {
		fake.updatePaymentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatePaymentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeConnMutex.RLock()
	defer fake.closeConnMutex.RUnlock()
	fake.createPaymentMutex.RLock()
	defer fake.createPaymentMutex.RUnlock()
	fake.getAllPaymentMutex.RLock()
	defer fake.getAllPaymentMutex.RUnlock()
	fake.getConnMutex.RLock()
	defer fake.getConnMutex.RUnlock()
	fake.getPaymentByIDMutex.RLock()
	defer fake.getPaymentByIDMutex.RUnlock()
	fake.getPaymentByNameMutex.RLock()
	defer fake.getPaymentByNameMutex.RUnlock()
	fake.getTxMutex.RLock()
	defer fake.getTxMutex.RUnlock()
	fake.openConnMutex.RLock()
	defer fake.openConnMutex.RUnlock()
	fake.startTxMutex.RLock()
	defer fake.startTxMutex.RUnlock()
	fake.updatePaymentMutex.RLock()
	defer fake.updatePaymentMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePaymentRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.PaymentRepository = new(FakePaymentRepository)
